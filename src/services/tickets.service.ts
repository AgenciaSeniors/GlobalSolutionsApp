/**
 * @fileoverview Service layer for agent support tickets (Module 5).
 * Uses agent_tickets + agent_ticket_messages for threaded conversations.
 * @module services/tickets.service
 */
import { createClient } from '@/lib/supabase/client';
import type {
  AgentTicket,
  AgentTicketWithDetails,
  TicketMessage,
  TicketCategory,
  TicketPriority,
} from '@/types/models';

export type { AgentTicket as Ticket };

export interface CreateTicketPayload {
  subject: string;
  message: string;
  priority: string;
  category?: string;
  created_by: string;
}

export const ticketService = {
  /**
   * Get all tickets created by or assigned to the current agent.
   */
  async getMyTickets(userId: string): Promise<AgentTicketWithDetails[]> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('agent_tickets')
      .select(`
        *,
        creator:profiles!created_by(full_name, email, role),
        assignee:profiles!assigned_to(full_name, email, role)
      `)
      .or(`created_by.eq.${userId},assigned_to.eq.${userId}`)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return (data ?? []) as unknown as AgentTicketWithDetails[];
  },

  /**
   * Get all tickets (admin view).
   */
  async getAllTickets(): Promise<AgentTicketWithDetails[]> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('agent_tickets')
      .select(`
        *,
        creator:profiles!created_by(full_name, email, role, agent_code),
        assignee:profiles!assigned_to(full_name, email, role)
      `)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return (data ?? []) as unknown as AgentTicketWithDetails[];
  },

  /**
   * Create a new ticket + initial message.
   */
  async createTicket(payload: CreateTicketPayload) {
    const supabase = createClient();

    // 1. Create the ticket
    const { data: ticket, error: ticketErr } = await supabase
      .from('agent_tickets')
      .insert({
        subject: payload.subject,
        category: (payload.category as TicketCategory) || 'general',
        priority: (payload.priority as TicketPriority) || 'medium',
        created_by: payload.created_by,
        description: payload.message,
        status: 'open',
        ticket_code: '', // auto-generated by trigger
      })
      .select()
      .single();

    if (ticketErr || !ticket) throw ticketErr || new Error('Error creating ticket');

    // 2. Insert the first message in the conversation thread
    const { error: msgErr } = await supabase
      .from('agent_ticket_messages')
      .insert({
        ticket_id: ticket.id,
        sender_id: payload.created_by,
        message: payload.message,
        is_internal: false,
      });

    if (msgErr) console.error('Error inserting initial ticket message:', msgErr);

    return ticket;
  },

  /**
   * Get messages for a specific ticket.
   */
  async getTicketMessages(ticketId: string): Promise<TicketMessage[]> {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('agent_ticket_messages')
      .select(`
        *,
        sender:profiles!sender_id(full_name, role)
      `)
      .eq('ticket_id', ticketId)
      .order('created_at', { ascending: true });

    if (error) throw error;
    return (data ?? []) as unknown as TicketMessage[];
  },

  /**
   * Reply to a ticket.
   */
  async replyToTicket(ticketId: string, senderId: string, message: string, isInternal = false) {
    const supabase = createClient();

    const { error: msgErr } = await supabase
      .from('agent_ticket_messages')
      .insert({
        ticket_id: ticketId,
        sender_id: senderId,
        message,
        is_internal: isInternal,
      });

    if (msgErr) throw msgErr;
  },

  /**
   * Update ticket status (admin or assigned agent).
   */
  async updateTicketStatus(ticketId: string, status: string) {
    const supabase = createClient();
    const { error } = await supabase
      .from('agent_tickets')
      .update({ status })
      .eq('id', ticketId);

    if (error) throw error;
  },

  /**
   * Assign ticket to an agent (admin action).
   */
  async assignTicket(ticketId: string, agentId: string) {
    const supabase = createClient();
    const { error } = await supabase
      .from('agent_tickets')
      .update({ assigned_to: agentId, status: 'in_progress' })
      .eq('id', ticketId);

    if (error) throw error;
  },
};
